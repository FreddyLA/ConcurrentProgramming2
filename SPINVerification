#define N 4

int mutex = 1;
int clockwise = 0;
int counterClockwise = 0;

int nClockwise = 0;
int nCounterClockwise = 0;

int dClockwise = 0;
int dCounterClockwise = 0;


inline Signal() {
	if
	:: nClockwise == 0 && dCounterClockwise > 0 ->  dCounterClockwise--;
													V(counterClockwise)
	:: nCounterClockwise == 0 && dClockwise > 0 ->  dClockwise--;
													V(clockwise)
	:: else -> V(mutex)
	fi
}

inline P(X) {
	atomic {X > 0 -> X = X - 1}
} 

inline V(X) { 
	X++
}

active [N] proctype Car()
{
	do
	::	skip;  /* Dummy statement to allow label at entry point */

entry:
		P(mutex);
		if
		:: _pid < N/2 ->
entry_1:				if
						:: nClockwise > 0 ->
											dCounterClockwise++;
											V(mutex);
											P(counterClockwise)
						:: else ->
						fi;
crit_1:					nCounterClockwise++
		:: else ->
entry_2:				if
						:: nCounterClockwise > 0 ->
											dClockwise++;
											V(mutex);
											P(clockwise)
						:: else ->
						fi;
crit_2: 				nClockwise++
		fi;
		Signal();
		P(mutex);
crit:	if
		:: _pid < N/2 -> nCounterClockwise--
		:: else -> nClockwise--;
		fi;
		Signal()
	od
}

ltl live {[] (Car[0]@entry -> <> Car[0]@crit)}
//ltl fair {[] (Car[0]@entry_1 -> <> Car[0]@crit_1)}
//ltl safety {[] (nClockwise == 0 || nCounterClockwise == 0)}
